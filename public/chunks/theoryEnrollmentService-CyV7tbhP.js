import{g as a}from"./cascade-deletion-BvQll6O-.js";class h{async enrollStudent(t,e,n={}){const r=n.transaction||null;try{console.log(`üéì Starting enrollment: Student ${e} ‚Üí Theory Lesson ${t}`);const o=await this.validateEnrollment(t,e);if(!o.isValid)throw new Error(`Enrollment validation failed: ${o.errors.join(", ")}`);if(o.enrollmentStatus==="waitlist")return await this.addToWaitlist(t,e,r);const s={studentId:e,enrolledAt:new Date().toISOString(),status:"active",enrollmentMethod:n.method||"manual",performedBy:n.performedBy||"system"},l=await this.addStudentToLesson(t,s,r),i={lessonId:t,enrolledAt:s.enrolledAt,status:"active",performance:{attendanceRate:0,lastAttended:null,grade:null,notes:""},auditTrail:[{action:"enrolled",performedAt:s.enrolledAt,performedBy:s.performedBy,reason:n.reason||"Manual enrollment"}]};return await this.addLessonToStudent(e,i,r),console.log(`‚úÖ Successfully enrolled student ${e} in theory lesson ${t}`),{success:!0,status:"enrolled",lesson:l,enrollmentData:i}}catch(o){throw console.error("‚ùå Enrollment failed:",o),await this.rollbackEnrollment(t,e,r),new Error(`Failed to enroll student: ${o.message}`)}}async unenrollStudent(t,e,n={}){const r=n.transaction||null;try{if(console.log(`üéì Starting unenrollment: Student ${e} ‚Üê Theory Lesson ${t}`),!await this.getStudentEnrollment(t,e))throw new Error("Student is not enrolled in this theory lesson");return await this.removeStudentFromLesson(t,e,r),await this.removeLessonFromStudent(e,t,n.reason||"Manual unenrollment",r),await this.processWaitlist(t,r),console.log(`‚úÖ Successfully unenrolled student ${e} from theory lesson ${t}`),{success:!0,status:"unenrolled",processedWaitlist:!0}}catch(o){throw console.error("‚ùå Unenrollment failed:",o),new Error(`Failed to unenroll student: ${o.message}`)}}async validateEnrollment(t,e){try{const n=await fetch(`${a.baseURL}/theory/${t}`,{headers:a.getHeaders()}),r=await fetch(`${a.baseURL}/student/${e}`,{headers:a.getHeaders()}),o=[];let s="enrolled",l=null,i=null;if(!n.ok)o.push(`Theory lesson not found (ID: ${t})`);else{const c=await n.json();l=c.data||c,l.isActive===!1&&o.push("Theory lesson is inactive")}if(!r.ok)o.push(`Student not found (ID: ${e})`);else{const c=await r.json();i=c.data||c,i.isActive===!1&&o.push("Student is inactive")}if(o.length>0)return{isValid:!1,errors:o,enrollmentStatus:null};l.studentIds?.includes(e)&&o.push("Student is already enrolled in this lesson");const d=l.studentIds?.length||0,u=l.maxStudents||1/0;return u&&d>=u&&o.push("Theory lesson is full"),{isValid:o.length===0,errors:o,enrollmentStatus:s,lesson:l,student:i}}catch(n){return console.error("Validation error:",n),{isValid:!1,errors:[`Validation failed: ${n.message}`],enrollmentStatus:null}}}validateAcademicRequirements(t,e){const n=[],r=e.academicRequirements||{},o=t.academicInfo?.class,s=r.targetGrades||[];s.length>0&&!s.includes(o)&&n.push(`Student grade "${o}" not eligible (requires: ${s.join(", ")})`);const l=t.academicInfo?.theoryLevel||"beginner",i=r.level;i&&i!=="all"&&i!==l&&n.push(`Student level "${l}" not compatible with lesson level "${i}"`);const d=r.prerequisites||[],u=t.academicInfo?.completedCourses||[],c=d.filter(m=>!u.includes(m));return c.length>0&&n.push(`Missing prerequisites: ${c.join(", ")}`),{isValid:n.length===0,errors:n}}async validateScheduleConflicts(t,e){try{const n=[],r=e.schedule,o=t.enrollments?.theoryLessons||[];for(const s of o){if(s.status!=="active")continue;const l=await a.get(`/theory/${s.lessonId}`);this.hasScheduleConflict(l.schedule,r)&&n.push(`Schedule conflicts with "${l.title||l.category}"`)}return{isValid:n.length===0,errors:n}}catch(n){return{isValid:!1,errors:[`Schedule validation failed: ${n.message}`]}}}hasScheduleConflict(t,e){if(t.dayOfWeek!==e.dayOfWeek)return!1;const n=i=>{const[d,u]=i.split(":").map(Number);return d*60+u},r=n(t.startTime),o=n(t.endTime),s=n(e.startTime),l=n(e.endTime);return r<l&&s<o}async addStudentToLesson(t,e,n=null){return await a.post(`/theory/${t}/student`,{studentId:e.studentId})}async addLessonToStudent(t,e,n=null){return console.log("‚úì Student document updated by backend addStudentToTheory"),Promise.resolve({success:!0})}async removeStudentFromLesson(t,e,n=null){return await a.delete(`/theory/${t}/student/${e}`)}async removeLessonFromStudent(t,e,n,r=null){return console.log("‚úì Student document updated by backend removeStudentFromTheory"),Promise.resolve({success:!0})}async getStudentEnrollment(t,e){try{const n=await a.get(`/theory/${t}`),r=n?.data||n;return r.studentIds?.includes(e)?{studentId:e,lessonId:t,status:"active",enrolledAt:r.updatedAt||new Date().toISOString()}:r.enrollment?.enrolledStudents?.find(s=>s.studentId===e&&["active","waitlist"].includes(s.status))||null}catch(n){return console.error("Error getting enrollment status:",n),null}}async addToWaitlist(t,e,n=null){const r={studentId:e,queuedAt:new Date().toISOString(),position:await this.getNextWaitlistPosition(t)},o={$push:{"enrollment.waitlist":r},$set:{updatedAt:new Date().toISOString()}};return await a.patch(`/theory/${t}`,o,{transaction:n}),{success:!0,status:"waitlist",position:r.position}}async processWaitlist(t,e=null){try{const r=(await a.get(`/theory/${t}`)).enrollment?.waitlist||[];if(r.length===0)return!1;const o=r.sort((s,l)=>new Date(s.queuedAt)-new Date(l.queuedAt))[0];return await this.enrollFromWaitlist(t,o.studentId,e),!0}catch(n){return console.error("Error processing waitlist:",n),!1}}async enrollFromWaitlist(t,e,n=null){const r={studentId:e,enrolledAt:new Date().toISOString(),status:"active",enrollmentMethod:"waitlist_promotion",performedBy:"system"},o={$pull:{"enrollment.waitlist":{studentId:e}},$push:{"enrollment.enrolledStudents":r},$inc:{"capacity.currentEnrollment":1},$set:{updatedAt:new Date().toISOString()}};await a.patch(`/theory/${t}`,o,{transaction:n});const s={$set:{"enrollments.theoryLessons.$[elem].status":"active","enrollments.theoryLessons.$[elem].enrolledAt":r.enrolledAt,updatedAt:new Date().toISOString()},$push:{"enrollments.theoryLessons.$[elem].auditTrail":{action:"promoted_from_waitlist",performedAt:r.enrolledAt,performedBy:"system",reason:"Space became available"}}},l=[{"elem.lessonId":t,"elem.status":"waitlist"}];return await a.patch(`/student/${e}`,s,{transaction:n,arrayFilters:l}),console.log(`üéØ Promoted student ${e} from waitlist to active enrollment`),r}async getNextWaitlistPosition(t){try{return((await a.get(`/theory/${t}`)).enrollment?.waitlist||[]).length+1}catch(e){return console.error("Error getting waitlist position:",e),1}}async rollbackEnrollment(t,e,n=null){try{console.log(`üîÑ Rolling back enrollment for student ${e}`),await this.removeStudentFromLesson(t,e,n).catch(r=>console.log("Lesson rollback not needed:",r.message)),await this.removeLessonFromStudent(e,t,"Rollback due to error",n).catch(r=>console.log("Student rollback not needed:",r.message)),console.log(`‚úÖ Rollback completed for student ${e}`)}catch(r){console.error("‚ùå Rollback failed:",r),await this.logCriticalError("rollback_failed",{lessonId:t,studentId:e,error:r.message})}}async logCriticalError(t,e){try{await a.post("/system/errors",{type:t,context:e,timestamp:new Date().toISOString(),severity:"critical",service:"theory-enrollment"})}catch(n){console.error("Failed to log critical error:",n)}}}const g=new h;export{g as t};
